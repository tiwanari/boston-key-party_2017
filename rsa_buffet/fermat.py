#! /usr/bin/python

import random
import fractions
from Crypto.Cipher import AES,PKCS1_OAEP
from Crypto.PublicKey import RSA
from base64 import b64decode

import sys, os

def decrypt(private_key, ciphertext):
  """Decrypt a message with a given private key.

  Takes in a private_key generated by Crypto.PublicKey.RSA, which must be of
  size exactly 4096

  If the ciphertext is invalid, return None
  """
  if len(ciphertext) < 512 + 16:
    return None
  msg_header = ciphertext[:512]
  msg_iv = ciphertext[512:512+16]
  msg_body = ciphertext[512+16:]
  try:
    symmetric_key = PKCS1_OAEP.new(private_key).decrypt(msg_header)
  except ValueError:
    return None
  if len(symmetric_key) != 32:
    return None
  return AES.new(symmetric_key,
      mode=AES.MODE_CFB,
      IV=msg_iv).decrypt(msg_body)


def isqrt(n):
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n//x) // 2
    return x

def is_square(n):
    if not n % 48 in (0, 1, 4, 9, 16, 25, 33, 36):
        return False

    x = isqrt(n)
    return x*x == n

def lcm(x, y):
    return x * y // fractions.gcd(x, y)

def fermat(n):
    a = isqrt(n)
    b2 = a*a - n
    while not is_square(b2):
        a += 1
        b2 = a*a - n
    return a - isqrt(b2)


def ex_euclid(x, y):
    c0, c1 = x, y
    a0, a1 = 1, 0
    b0, b1 = 0, 1
 
    while c1 != 0:
        m = c0 % c1
        q = c0 // c1
 
        c0, c1 = c1, m
        a0, a1 = a1, (a0 - q * a1)
        b0, b1 = b1, (b0 - q * b1)
 
    return c0, a0, b0

def rsa_gen_d(p,q):
  e = 65537
  l = lcm(p-1, q-1)
  c, a, b = ex_euclid(e, l)
  d = a % l
  return d

if __name__ == '__main__':
    key_file = "./rsa-buffet/key-1.pem"
    key = open(key_file).read()
    imported = RSA.importKey(key)

    p = fermat(imported.n)
    q = imported.n / p
    print "p = "+ str(p)
    print "q = "+ str(q)

    d = rsa_gen_d(p,q)
    print d
    new_key = RSA.construct((imported.n,imported.e,d))

    for i in range(1,6):
      cipher_file = "./rsa-buffet/ciphertext-" + str(i) + ".bin"
      cipher = open(cipher_file).read()
      result = decrypt(new_key, cipher)
      if result:
        print cipher_file + " => "
        print result
        break
