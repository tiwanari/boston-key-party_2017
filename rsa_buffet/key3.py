#!/usr/bin/python

import random
from Crypto.Cipher import AES,PKCS1_OAEP
from Crypto.PublicKey import RSA
from base64 import b64decode

import sys, os
sys.path.append(os.path.join(os.path.dirname(__file__), "wiener"))
import RSAwienerHacker


def decrypt(private_key, ciphertext):
  """Decrypt a message with a given private key.

  Takes in a private_key generated by Crypto.PublicKey.RSA, which must be of
  size exactly 4096

  If the ciphertext is invalid, return None
  """
  if len(ciphertext) < 512 + 16:
    return None
  msg_header = ciphertext[:512]
  msg_iv = ciphertext[512:512+16]
  msg_body = ciphertext[512+16:]
  try:
    symmetric_key = PKCS1_OAEP.new(private_key).decrypt(msg_header)
  except ValueError:
    return None
  if len(symmetric_key) != 32:
    return None
  return AES.new(symmetric_key,
      mode=AES.MODE_CFB,
      IV=msg_iv).decrypt(msg_body)


if __name__=="__main__":
  key_file = "./rsa-buffet/key-3.pem"
  key = open(key_file).read()

  imported = RSA.importKey(key)
  print "e: " + str(imported.e)
  print "n: " + str(imported.n)

  # increase the limit counts of recursions
  # print sys.getrecursionlimit() # => 1000
  sys.setrecursionlimit(10000)

  d = RSAwienerHacker.hack_RSA(imported.e,imported.n)
  print "d: " + str(d)

  new_key = RSA.construct((imported.n,imported.e,d))

  for i in range(1,6):
    cipher_file = "./rsa-buffet/ciphertext-" + str(i) + ".bin"
    cipher = open(cipher_file).read()
    result = decrypt(new_key, cipher)
    if result:
      print cipher_file + " => "
      print result
      break
